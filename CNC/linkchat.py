import socket
import threading
import queue
import time
from configparser import ConfigParser
import time
import os
def inicio():
    x=0
    while x!=7:
        print("iniciando servidor ...")
        time.sleep(0.02)
        os.system('clear')
        print("iniciando servidor .. ")
        time.sleep(0.02)
        os.system('clear')
        print("iniciando servidor .")
        time.sleep(0.02)
        os.system('clear')
        print("iniciando servidor ..")
        time.sleep(0.02)
        os.system('clear')
        print("iniciando servidor ... ")
        time.sleep(0.02)
        os.system('clear')
        x+=1
inicio()




#leyendo archivo de configuracion
# config_object = ConfigParser()
# path = '/'.join((os.path.abspath(__file__).replace('\\', '/')).split('/')[:-1])
# config_object.read(os.path.join(path, 'server-config.ini'))
# #Get the password
# serverconfig = config_object["serverconfig"]



# dominio=("{}".format(serverconfig["HOST"]))
# dominio=(serverconfig["HOST"])
HOST = "localhost"#socket.gethostbyname(dominio)


PORT=4444#("{}".format(serverconfig["PORT"]))


# max_listen = ("{}".format(serverconfig["MAX_LISTEN"]))

# ENCODING=("{}".format(serverconfig["ENCODING"]))


print(max)

#clase de servidor
class Server(threading.Thread):

    #se pasan los parametros de port, host
    def __init__(self, host, port):
        super().__init__(daemon=False, target=self.run)

        self.host = host
        self.port = port
        self.max_listen = 10#(serverconfig["MAX_LISTEN"])
        #maximo de datos permitidos por mensaje
        self.buffer_size = 1024#int(serverconfig["BUFFER"])
        #tipo de socket
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        self.connection_list = []
        self.login_list = {}
        self.queue = queue.Queue()

        self.shutdown = False
        try:
            #bindear al socket con el host y el puerto
            self.sock.bind((str(self.host), int(self.port)))
            #numero maximo de escuchas del servidor
            self.sock.listen(int(self.max_listen))
            #socket no bloqueante
            self.sock.setblocking(False)
            #si no es posible la conexion se cierra el socket
        except socket.error:
            self.shutdown = True
        # si el socket no se apaga
        if not self.shutdown:
            #llama a la funcion de escucha (listen)
            listener = threading.Thread(target=self.listen, daemon=True)
            #llama a la funcion de recibir (receive)
            receiver = threading.Thread(target=self.receive, daemon=True)
            #llama a la funcion de envio (sender)
            sender = threading.Thread(target=self.send, daemon=True)
            self.lock = threading.RLock()

            listener.start()
            receiver.start()
            sender.start()
            self.start()
    #funcion de ejecucion
    def run(self):
        """metodo de hilo principal"""
        #si escribes 'quit' se cierra el servidor
        print("Enter \'quit\' to exit")
        while not self.shutdown:
            #mientras que no este apagado puedes introducir comandos
            message = input('-->')
            if message == "quit":
                self.sock.close()
                self.shutdown = True
            elif message == "--help" or message == "-h":
                print(" -kick <<username>>          kick a user")
                print(" -l  or  --list-users        list users")
            elif message == "clear" or message == "cls":
                os.system('cls')
            elif message == "list users" or message == "--list-users" or message == "-l":
                try:
                    if self.login_list:
                        for x in self.login_list:
                            print (x)
                    else:
                        print ("no hay nadie conectado")
                        #print ('\n')
                except:

                    pass
    #funcion de escucha
    def listen(self):
        """escuchar nuevas conexiones"""
        print('iniciado hilo de escucha')
        while True:
            try:
                #se bloquea la funcion
                self.lock.acquire()
                #aceptar conexion
                connection, address = self.sock.accept()
                connection.setblocking(False)
                #si la conexion y la ip no esta en la lista la añade
                if connection not in self.connection_list:
                    self.connection_list.append(connection)
            except socket.error:
                pass
            finally:
                #se desbloquea la funcion
                self.lock.release()
            time.sleep(0.050)
    #fucnion recibir
    def receive(self):
        """escuchando nuevos mensajes"""
        print('inicializado hilo de recibir')
        while True:
            #si en la lista de connection_list hay mas de 0 es que hay clientes
            if len(self.connection_list) > 0:
                for connection in self.connection_list:
                    try:
                        self.lock.acquire()
                        #los datos recibidos
                        data = connection.recv(self.buffer_size)
                    except socket.error:
                        data = None
                    finally:
                        self.lock.release()
                    #se procesan los datos recividos con una funcion mas abajo (process_data)
                    self.process_data(data, connection)
    #fucnion enviado
    def send(self):
        """enviar mensajes desde la cola del servidor"""
        print('hilo de envio inicializado')
        while True:
            #si la cola no esta vacia
            if not self.queue.empty():
                #desde el origen hasta el target se recoge la data
                target, origin, data = self.queue.get()
                #si el target es all se envia a todo el mundo con la funcion de (send_to_all) abajo
                if target == 'all':
                    self.send_to_all(origin, data)
                else:
                    #si no se envia solo al target con la funcion (send_to_one)
                    self.send_to_one(target, data)
                self.queue.task_done()
            else:
                time.sleep(0.05)
    #funcion de envio a todos
    def send_to_all(self, origin, data):
        """enviando datos a todo el mundo menos el remitente"""
        #si el origen no es el server se añade a la lista de (login_list)
        if origin != 'server':
            origin_address = self.login_list[origin]
        else:
            #si no no hay origen
            origin_address = None
        #envio de datos
        for connection in self.connection_list:
            # si el origen no es igual a los enviados
            if connection != origin_address:
                try:
                    #se envian los datos
                    self.lock.acquire()
                    connection.send(data)
                except socket.error:
                    #si hay un error se cierra y se quita la conexion
                    self.remove_connection(connection)
                finally:
                    self.lock.release()
    #funcion de envio a una persona se recogen los parametros de (target, data)
    def send_to_one(self, target, data):
        """se envia a una persona especifica"""
        #de los nicknames que hay se elige uno y se guarda en target_address
        target_address = self.login_list[target]
        try:
            #se envian los datos a la persona elegida
            self.lock.acquire()
            target_address.send(data)
        except socket.error:
            #si falla se borra la conexion
            self.remove_connection(target_address)
        finally:
            self.lock.release()
    #procesamiento de datos recibidos
    def process_data(self, data, connection):
        """Process received data"""
        if data:
            #la variable message es la data .decode(codificacion elegida al principio)
            message = data.decode(ENCODING)
            # en una array separa cada mensaje entero: no ["hola", "que", "haces"] si ["hola que haces"]
            message = message.split(";", 3)

            #si en la posicion 0 del mensaje esta 'login' se le asigna el nombre de la posicion 1
            if message[0] == 'login':
                tmp_login = message[1]
                #esto es el login, si el nombre esta en uso se pondra # despues de el nombre
                while message[1] in self.login_list:
                    message[1] += '#'
                if tmp_login != message[1]:
                    prompt = 'msg;server;' + message[1] + ';Login ' + tmp_login \
                             + ' already in use. Your login changed to ' + message[1] + '\n'
                    self.queue.put((message[1], 'server', prompt.encode(ENCODING)))
                #avisa quien se ha unido
                self.login_list[message[1]] = connection
                print(message[1] + ' has logged in')
                self.update_login_list()
            #si el mensaje es logout se quita de la lista
            elif message[0] == 'logout':
                self.connection_list.remove(self.login_list[message[1]])
                if message[1] in self.login_list:
                    del self.login_list[message[1]]
                print(message[1] + ' has logged out')
                self.update_login_list()

            elif message[0] == 'msg' and message[2] != 'all':
                msg = data.decode(ENCODING) + '\n'
                data = msg.encode(ENCODING)
                self.queue.put((message[2], message[1], data))

            elif message[0] == 'msg':
                msg = data.decode(ENCODING) + '\n'
                data = msg.encode(ENCODING)
                self.queue.put(('all', message[1], data))
    #fucnion de remover la conexion de la lista
    def remove_connection(self, connection):
        """Remove connection from server's connection list"""
        self.connection_list.remove(connection)
        for login, address in self.login_list.items():
            if address == connection:
                del self.login_list[login]
                break
        self.update_login_list()
    #fucnion de actualizar la lista de login
    def update_login_list(self):
        """Update list of active users"""
        logins = 'login'
        for login in self.login_list:
            logins += ';' + login
        logins += ';all' + '\n'
        self.queue.put(('all', 'server', logins.encode(ENCODING)))


# Create new server with (IP, port)
if __name__ == '__main__':
    server = Server(HOST, PORT)